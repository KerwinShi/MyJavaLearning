一、日志概览
=  
1.日志是干什么的
-  
日志用来记录程序的运行轨迹，方便查找关键信息和快速定位解决问题。（开发的时候，我们可以使用IDE进行debug，但是测试与生产环境下就不行了，好的日志可以快速单位问题解决问题）  

2.日志有什么用
-  
问题追踪、状态监控、安全审计

二、日志使用  
=  
1.常用框架
-  
### 2.1.1Logging（JUL）  
Java自带的日志工具类，基本没人在使用了已经。  
### 2.1.2commons-logging  
日志门面接口，用户选择不同日志实现框架，不必改动日志定义，面向接口抽象编程，少有人用已经。  
### 2.1.3slf4j  
为Java提供的简单日志facade（接口，众多接口的集合，不负责实现，只负责找合适的日志系统进行绑定），允许根据自己的喜好接入不同的日志系统（slf4j-api）。 
一个loggerfactory的工厂类，不需要在代码中或配置文件中指定使用日志系统，在部署的时候不修改任何配置即可接入一种日志方案，在编译的时候才绑定真正的log库。  
需要使用某种日志实现，必须正确选择slf4j的jar包集合（桥接包），logback是天然实现，不需要桥接包也可以使用。   
### 2.1.4Log4j  
开源日志框架，最为广泛的应用框架。（停止维护，切换至log4j2）  
### 2.1.5Log4j2  
Log4j升级版，不兼容Log4j，Log4j2利用Java5中的并发特性支持，尽可能地执行最低层次的加锁。解决了在log4j 1.x中存留的死锁的问题。Log4j 2是基于LMAX Disruptor库的。在多线程的场景下，和已有的日志框架相比，异步logger拥有10倍左右的效率提升。  
![log4j2体系结构](./image/logger/log4j2体系结构.jpg "log4j2")
### 2.1.6Logback  
Log4j的原生框架，出于同一人之手，但更多的有点、特性和更强的性能，代替Log4j成为主流。  
分为三个模块：logback-core、logback-classic和logback-access。其中core是基础，classic是log4j的改良版本，access与servlet容器集成通过提供http来访问日志的功能。（优点还很多，具体以后遇到补充）

![各日志框架关系图](./image/logger/日志框架关系图.jpg "关系图")

选择原则：
没有最好，只有合适不合适。
关注高性能：slf4j + logback  
已经使用log4j，继续使用更好：slf4j + log4j2  
不想有依赖，java.util.logging或框架容器已经提供的日志接口  

PS:
### 2.1.7Avalon LogKit  
一个高速日志记录工具集，可以记录多项内容，甚至可以记录到数据库对应字段，支持多种存储目标。  

冲突处理：  
能够对各类冲突支持比较到位的就是slf4j和log4j2，提供了绑定器和桥接器（绑定器：适配器或者包装类，就是将特定api打点的日志绑定到具体日志实现组件来输出）（桥接器：是一个假的日志实现工具，比如当你把 jcl-over-slf4j.jar 放到 CLASS_PATH 时，即使某个组件原本是通过 JCL 输出日志的，现在却会被 jcl-over-slf4j “骗到”SLF4J 里，然后 SLF4J 又会根据绑定器把日志交给具体的日志实现工具。具体还需进一步学习。。。。。）

三、什么时候使用日志
=  
乱用日志的后果：有效的日志信息被无效的日志信息淹没，日志失去应该有的效果。  

常见的需要日志的点：
* 编程语言提示异常
* 业务流程预期不符合（参数是否正确，处理数据问题导致返回码不在合理范围等等）
* 系统核心角色，组件关键动作（核心数据表增删改；核心组件运行）
* 系统初始化，系统或者服务的启动参数  

四、日志最佳实践（使用约定）
=  
4.1日志变量的定义
-
日志变量往往不变，一个类只有一个log对象，有父类就定义在父类中。  
```
private static final Logger log = LoggerFactory.getLogger({SimpleClassName}.getClass());
```  
这里使用Logger，是因为log4j、logback等日志实现框架，实现了slf4j的门面接口（推荐引入lombok依赖，类头部注解@slf4j，可以使用log变量打印日志，代码更简洁）  

4.2参数占位格式
-  
使用参数化形式{}占位，[]进行参数隔离  
```
log.debug("Save order with order no：[{}], and order amount：[{}]");  
log.debug("Save order with order no：[{}], and order amount：[{}]");
```  
若日志不支持参数化，且日志输出不支持该日志级别会导致对象的冗余创建，浪费内存，使用isXXEnable（）进行判断  
```
if(log.isDebugEnabled()){
    // 如果日志不支持参数化形式，debug又没开启，那字符串拼接就是无用的代码拼接，影响系统性能  
    log.debug("Save order with order no：" + orderNo + ", and order amount：" + orderAmount);
}
```  

4.3日志的格式
-  
主要包括内容如下： 
* 日志时间  
日记产生时间和日期，精确到毫秒
* 日志级别  
分级别，不同的设置不同场合打印不同日志
    - DEBUG主要输出调试性质的内容，用于开发测试阶段输出。写的时候尽可能详细，以达到调试的目的。
    - INFO记录系统关键信息，保留系统正常工作期间关键运行指标，如初始化配置、业务状态变化信息或者用户业务流程中的核心记录处理
    - WARN输出警告性质的内容，可以预知且有规划，方法参数不满足方法要求
    - ERROR不可预知的信息，错误，异常，若异常对系统影响不大，可以使用WARN，使用ERROR是应该尽量多的输出方法输入参数、方法执行过程中产生的对象数据等。  
    （INFO和DEBUG）  
    DEBUG级别比INFO低，包含调试时更详细的了解系统运行状态的东西，比如变量的值等等，都可以输出到DEBUG日志里。 INFO是在线日志默认的输出级别，反馈系统的当前状态给最终用户看的。尝试记录INFO日志会被频繁打印或者大部分时间对于纠错起不到作用，就应当考虑下调为DEBUG级别。（日志输出是多线程公用的，如果有另外一个线程正在输出日志，上面的记录就会被打断，最终显示输出和预想的就会不一致）  
    （WARN和ERROR）  
    ERROR级别的日志意味着系统中发生了非常严重的问题，必须有人马上处理，比如数据库不可用，系统的关键业务流程走不下去等等。WARN代表可恢复的异常，此次失败不影响下次业务的执行

* 调用链标识（可选）  
在分布式应用中，用户的一个请求会调用若干个服务完成，这些服务可能还是嵌套调用的，因此完成一个请求的日志并不在一个应用的日志文件，而是分散在不同服务器上不同应用节点的日志文件中。该标识是为了串联一个请求在整个系统中的调用日志。
* 线程名称  
输出该日志的线程名称，一般在一个应用中一个同步请求由同一线程完成，输出线程名称可以在各个请求产生的日志中进行分类，便于分清当前请求上下文的日志。
* 日志记录器名称  
日志记录器名称一般使用类名，日志文件中可以输出简单的类名即可，看实际情况是否需要使用包名和行号等信息。主要用于看到日志后到哪个类中去找这个日志输出，便于定位问题所在。
* 日志内容  
    - 禁用 System.out.println和System.err.println
    - 变参替换日志拼接
    - 输出日志的对象，应在其类中实现快速的 toString 方法，以便于在日志输出时仅输出这个对象类名和 hashCode
    - 预防空指针:不要在日志中调用对象的方法获取值，除非确保该对象肯定不为 null，否则很有可能会因为日志的问题而导致应用产生空指针异常。
* 异常堆栈（不一定有）  
异常堆栈一般会出现在 ERROR 或者 WARN 级别的日志中，异常堆栈含有方法调用链的系统，以及异常产生的根源。

4.4日志使用规范
-  
* 在一个对象中通常只使用一个Logger对象，Logger应该是static final的，只有在少数需要在构造函数中传递logger的情况下才使用private final。
* 不要使用具体的日志实现类
* 输出Exceptions的全部Throwable信息。
* 不允许记录日志后又抛出异常。
* 不允许使用标准输出。
* 不允许出现printStackTrace。
* 禁止在线上环境开启debug级别日志输出。
* 不要在大循环中打印日志。
* 打印有意义的日志

五、参考
=  
[1] https://www.jianshu.com/p/546e9aace657  
[2] https://blog.csdn.net/Taobaojishu/article/details/107479049







