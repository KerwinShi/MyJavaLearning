1.硬件层面理解  
=  
![硬件模型](../../image/JVM/硬件模型.png)  
![硬件结构](../../image/java并发/硬件结构.png)  

>每一个CPU修改内存数据的步骤：  
>1.从内存中读取数据到缓存cache  
>2.在缓存种中更新数据  
>3.把更新结果刷新到内存中  

>当有多个cpu操作同一个数据的时候，如果不加以处理，这个数据就会出现数据不一致的问题，比如：一个cpu读，一个cpu写，cpu读到的数可能是改之前的也可能是改之后的  

解决方案：  
总线加锁（粒度太大）  
MESI(硬件层面上的实现)  
>读操作：不做任何事情，把cache中的数据读取到寄存器中  
>写操作：发出信号，告知其他cpu将该变量cache line置为无效（会导致增加很多的cache line），其他cpu要访问这个变量的时候，只能从内存中获取  

对应内存模型：  
![Java内存模型](../../image/JVM/Java内存模型.png)  
>主存中的数据所有线程都可以访问  
>每个线程都有自己的工作空间（本地内存）  
>工作空间数据：局部变量、内存副本  
>线程不能直接修改内存中的数据，只能读到工作空间中，再到寄存器中间进行修改，修改完成后刷新回内存中  

![JMM与硬件模型](../../image/JVM/JMM与硬件模型.png)  

2.volatile  
=  
让其他线程感知到有一个线程对变量进行了修改  
可见性：  
对共享变量的修改，其他线程马上可以感知到  
**不能保证原子性 读 写 ++**  
有序性：  
>重排序（编译阶段、指令优化阶段）输入程序的代码顺序并不是实际的顺序(为了提高CPU的吞吐量)，对于单线程没有影响（重排的前提是不能影响结果），但是对于多线程有影响  
对于volatile修饰的变量
volatile之前的代码不允许调整到他的后面  
volatile之后的代码不允许调整到他的前面  
霸道，位置的不变化  

理解volatile的原理与实现机制（锁，轻量级）  
>HSDIS--反编译--汇编 可以看出来是加了锁lock   

3.使用场景  
=   
开关模式（标志位用来控制开关）  
双重检查锁（单例模式DCL）  
需要利用顺序性  



4.volatile  vs  synchronized  
使用上：  
>volatile只能修饰变量，synchronized只能修饰方法与语句块  
原子性：  
>volatile无法保证，synchronized可以保证  
可见性：  
>都可以保证可见性，但是实现原理不一致，volatile加了lock，synchronized加了monitorenter和monitorexit
有序性：  
>都可以保证有序性，但是synchronized付出的代价太大，重量级锁，并发退化为串行  
其他：  
>synchronized会引起阻塞，volatile不会










