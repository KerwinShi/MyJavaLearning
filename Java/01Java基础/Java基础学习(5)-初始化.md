对象的创建与清理：  
Java采用了构造器的概念，另外还使用了垃圾收集器自动回收不再被使用的对象所占的资源。  

Java中构造器名称与类名相同（不需要符合首字母小写的编程风格），在初始化过程中自动调用构造方法，对象的创建与初始化是统一的概念。  
无参构造器为默认构造器，构造器没有返回值（和返回void也是不同的）。  

为了可以以不同的方式完成对象的初始化，需要对构造器进行重载；重载中，基本类型可以自动从较小的类型转型为较大的类型（如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错）。
重载：（为了区分两个函数，唯一可行的办法就是通过参数列表，包括参数数量个参数的顺序；返回值不行，有的时候虽然有返回值，但是程序使用函数的时候不需要返回值，这时候程序无法判断到底是哪个函数被调用了）  
```java
void f(){}
int f() {return 1;}

//调用，但是不需要返回值，此时无法判断到底是谁
f();
```   

无参构造器：不接受参数的构造器，创建一个默认的对象，创建一个类，编译器会自动创建一个无参构造器，但是如果手动创建了一个构造器，无论是有参数还是没有参数，编译器都不会再创建一个无参构造器了。  


this关键字  
同一个类的不同对象调用同一个方法的时候，可以看成是把对象的引用作为一个隐秘的参数传递给编译器了（其实并没有在参数列表中，也不允许这么干），this关键字在我们调用一个对象的方法的时候生成一个对象引用，在一个类内部的方法里调用其他方法的时候不用this也可以，但是需要注意的是，this只能用于非静态方法内部。  

static  
static方法中不会存在this，所以不能再静态方法中调用非静态的方法，静态方法是为类创建的，不需要任何对象。  

垃圾回收：
对于使用new创建的对象，垃圾回收器知道如何释放内存，但是对于不是通过new分配的内存，垃圾回收器是不知道怎么回收内存的。

为了能够回收这部分不是通过new分配的内存，java语序在类中定义一个finalize()的方法\[在垃圾回收器回收内存前都会首先调用finalize()方法，并在下一轮的垃圾回收动作发生的时候真正回收内存，finalize()可以用来做一些重要的清理工作\]  
但是，但是，但是，
* 对象可能不被垃圾回收（内存没有到要被用完之前，对象占用空间可能一直不会被释放，程序结束，对象还没有被垃圾回收器回收，资源会直接还给操作系统）
* 垃圾回收不等于析构（如果在不需要一个对象之前，必须要执行某些动作的话，必须自己去做）
* 垃圾回收只和内存有关（是为了回收不再使用的内存，无论对象是如何创建的，垃圾回收器都会负责释放对象所占用的内存，也就说，其实finalize()是用来处理通过某种创建对象之外的方式为对象分配的内存空间，直白一点就是java调用一些非java代码分配的空间，这些空间需要我们在finalize()中去释放，否则垃圾回收器是没办法处理的）  

要清理一个对象，我们必须在需要清理的的时候执行清理动作的方法（光靠垃圾回收器是不够的，如果希望进行除释放存储空间之外的清理工作，还是得明确调用恰当的java方法，这样才等同于析构函数）  

finalize()通常只会被用于极少数非常晦涩的内存清理，但是他还可以有另外的一个用途：对象终结条件的校验（程序中一个对象打开了一个文件，在这个对象被回收之前，应该关闭文件，但是有时会忘记，这就是一个bug，finalize()可以用来最终发现这个情况，虽然这个函数不一定会被执行，但是只要有一次被执行了，就可以用来找到那些隐藏的bug）


垃圾回收器是如何工作的  
其他语言中，在堆内存上分配对象的代价是十分高昂的，但是在java中，由于垃圾回收器的存在，在堆上创建对象几乎和在栈上创建对象速度一样，这是因为其他语言（c++）在堆上分配内存的时候就像一个院子，对象在里面有自己的地盘，对象可能被销毁，但是地盘要复用，而在java的一些虚拟机中则不然，更像是传送带，分配一个对象，就向前移动一格，速度极快，几乎与栈上操作效率相当（不完全是传送带那种感觉，一直移动会导致内存页面调度，降低效率，最终内存耗尽），垃圾回收器的介入，会一边回收内存，一边使堆中的对象排列紧凑（重排列对象）

垃圾回收机制：  
1.引用计数，每当引用指向对象，对象中的引用计数器就加1，当引用离开作用域或者被置为null，计数器减1，垃圾回收器便利对象列表，对于计数为0的对象，回收内存，释放占用空间。缺点是对象之间存在循环引用的时候，对象无法回收，如果要定位这样的对象，会产生非常大的工作量。这种机制用来说明垃圾回收的工作原理，但是没有被真正应用于java虚拟机中

2.自适应垃圾回收，对于任意活着的对象，一定可以找到其存活在栈上，或者静态存储区中的引用，从栈或静态存储区出发，遍历所有的引用，你将会发现所有"活"的对象，而那些对象间循环引用的对象，就不会被发现，最终被回收。不同虚拟机有不同的实现方法：
* 停止-复制：先暂停程序，复制所有活的对象从当前堆到另一个堆新的堆上，被复制的对象排列紧凑，没有复制的就回收了
    效率低下的原因：1两个独立的堆，来回折腾费时间，费空间；2垃圾是少数，为了这些少量的垃圾，复制大量的存活对象，浪费。
* 改进版：自适应模式，标记-清扫，对于没有垃圾活着少量的垃圾产生的情况，非常快，但是垃圾多的时候就非常慢。从栈和静态存储区出发，遍历所有的引用，找出所有存活的对象给对象设一个标记，标记完成后，才开始清理那些没有被标记的对象，并在最后进行对象重新整理，保持紧凑分布。  

这里的自适应模式说的是java虚拟机中，内存分配是以块为单位的，垃圾回收器在复制的时候把对象复制到废弃的块上,（每个块都有年代数记录自己是否存活，块被引用，年代数加1）。完成清理工作的时候，大型的对象不会复制，只是年代数增加，小型的对象则复制整理，如果所有对象都是稳定的，就会切换为标记-清扫，如果碎片很多，就会切换为停止-复制。

Java 虚拟机中有许多附加技术用来提升速度。尤其是与加载器操作有关的，被称为"即时"（Just-In-Time, JIT）编译器的技术，把程序全部或部分翻译成本地机器码。
如果，利用即时编译器编译所有代码，加载动作贯穿整个程序生命周期内，累加起来需要花更多时间，而且会增加可执行代码的长度，导致页面调度，从而一定降低程序速度。
通常采取的策略是惰性评估，即时编译器只有在必要的时候才编译代码。  


20201118阅读记录  
成员初始化：  
1. 默认值
对于方法的局部变量，没有初始化的变量会以编译时的错误方式体现出来，避免默认的值掩盖错误，不利于寻找bug所在  
对于是基本类型的类的成员变量，每个基本类型数据成员保证都会有一个初始值，不会出现未初始化变量的风险    
默认值列表  
```
boolean false
char[NUL]（char 值为 0，所以显示为空白）
byte 0
short 0
int 0
long 0
float 0.0
double 0.0
reference null（一个对象引用时，如果不将其初始化，那么引用就会被赋值为 null）
```

2. 指定初始化  
直接在定义类成员变量的地方为其赋值；也可以调用一个方法为其赋值（但是就和初始化程序顺序有关，在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化）  

3. 构造器初始化  
无法阻止自动初始化的进行，他会在构造器被调用之前发生（[类加载过程](./Java基础学习(97)-类加载过程.md)）  

静态数据初始化：  
静态数据无论创建多少个对象，都只有一份，如果没有对其进行初始化，就会设置为变为默认值。  

显式的静态初始化：  
静态代码块（首次加载类的时候执行一次）  

非静态实例初始化：  
代码块（构造之前执行）  