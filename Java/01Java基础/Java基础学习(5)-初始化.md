对象的创建与清理：  
Java采用了构造器的概念，另外还使用了垃圾收集器自动回收不再被使用的对象所占的资源。  

Java中构造器名称与类名相同（不需要符合首字母小写的编程风格），在初始化过程中自动调用构造方法，对象的创建与初始化是统一的概念。  
无参构造器为默认构造器，构造器没有返回值（和返回void也是不同的）。  

为了可以以不同的方式完成对象的初始化，需要对构造器进行重载；重载中，基本类型可以自动从较小的类型转型为较大的类型（如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错）。
重载：（为了区分两个函数，唯一可行的办法就是通过参数列表，包括参数数量个参数的顺序；返回值不行，有的时候虽然有返回值，但是程序使用函数的时候不需要返回值，这时候程序无法判断到底是哪个函数被调用了）  
```java
void f(){}
int f() {return 1;}

//调用，但是不需要返回值，此时无法判断到底是谁
f();
```   

无参构造器：不接受参数的构造器，创建一个默认的对象，创建一个类，编译器会自动创建一个无参构造器，但是如果手动创建了一个构造器，无论是有参数还是没有参数，编译器都不会再创建一个无参构造器了。  


this关键字  
同一个类的不同对象调用同一个方法的时候，可以看成是把对象的引用作为一个隐秘的参数传递给编译器了（其实并没有在参数列表中，也不允许这么干），this关键字在我们调用一个对象的方法的时候生成一个对象引用，在一个类内部的方法里调用其他方法的时候不用this也可以，但是需要注意的是，this只能用于非静态方法内部。  

static  
static方法中不会存在this，所以不能再静态方法中调用非静态的方法，静态方法是为类创建的，不需要任何对象。  

垃圾回收：
对于使用new创建的对象，垃圾回收器知道如何释放内存，但是对于不是通过new分配的内存，垃圾回收器是不知道怎么回收内存的。

为了能够回收这部分不是通过new分配的内存，java语序在类中定义一个finalize()的方法\[在垃圾回收器回收内存前都会首先调用finalize()方法，并在下一轮的垃圾回收动作发生的时候真正回收内存，finalize()可以用来做一些重要的清理工作\]  
但是，但是，但是，
* 对象可能不被垃圾回收（内存没有到要被用完之前，对象占用空间可能一直不会被释放，程序结束，对象还没有被垃圾回收器回收，资源会直接还给操作系统）
* 垃圾回收不等于析构（如果在不需要一个对象之前，必须要执行某些动作的话，必须自己去做）
* 垃圾回收只和内存有关（是为了回收不再使用的内存，无论对象是如何创建的，垃圾回收器都会负责释放对象所占用的内存，也就说，其实finalize()是用来处理通过某种创建对象之外的方式为对象分配的内存空间，直白一点就是java调用一些非java代码分配的空间，这些空间需要我们在finalize()中去释放，否则垃圾回收器是没办法处理的）  

要清理一个对象，我们必须在需要清理的的时候执行清理动作的方法（光靠垃圾回收器是不够的，如果希望进行除释放存储空间之外的清理工作，还是得明确调用恰当的java方法，这样才等同于析构函数）  

finalize()通常只会被用于极少数非常晦涩的内存清理，但是他还可以有另外的一个用途：对象终结条件的校验（程序中一个对象打开了一个文件，在这个对象被回收之前，应该关闭文件，但是有时会忘记，这就是一个bug，finalize()可以用来最终发现这个情况，虽然这个函数不一定会被执行，但是只要有一次被执行了，就可以用来找到那些隐藏的bug）
