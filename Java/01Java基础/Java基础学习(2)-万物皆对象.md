“名字代表什么？玫瑰即使不叫玫瑰，也依旧芬芳”。（引用自 莎士比亚，《罗密欧与朱丽叶》）。  

Java中，虽然万物皆对象，，但我们所操纵的标识符实际上只是对对象的“引用”。  

1 对象的创建
- 
`String s = new String("asdf");`  
new 关键字代表：创建一个新的对象实例。  
创建对象后，就需要找地方存放他，存放的地方有：
* 寄存器：最快的存储区域，位于cpu内部，数量有限，无法直接控制，c++允许向编译器建议分配。
* 栈内存：常规RAM区域，栈指针获得处理器的支持。栈内存上存放部分java数据（如：对象引用），但是对象本身数据存放于堆内存。
* 堆内存：通用的内存池，也位于RAM区域，但是不需要像栈一样知道对象数据会存在多久。代价是，创建和清理数据的时候比较费时间。
* 常量存储：直接存放于程序代码，因为他们不会变化，为了保护数据可以放在ROM中。
* 非RAM存储：数据玩去存在于程序之外，程序未运行以及脱离程序控制后依然存在。主要是：序列化的对象，对象被转换为字节流发送到另一台机器；或者持久化对象，被放置到磁盘。总的来说就是就是将对象存在另一个介质，需要的时候恢复为RAM对象。Java提供轻量级持久化，而jdbc等类库为使用数据库存储检索对象信息提供了更复杂的支持。  

基本类型的存储  
由于new创建的数据类型都是存放在堆中的，对于一些简单的变量这么干是不合适的，对于这样的变量（java基本类型），变量直接存储值，位于栈内存中，更高效。

| 基本类型  |    大小 |  最小值  | 最大值  | 包装类型 |
| :------: | :------: | :------: | :------: | :------: |
| boolean | —  | — | — | Boolean |
| char | 16 bits | Unicode 0  | Unicode 2<sup>16</sup> -1  | Character |
| byte | 8 bits | -128 | +127 | Byte |
| short | 16 bits | - 2<sup>15</sup> | + 2<sup>15</sup> -1 | Short |
| int | 32 bits | - 2<sup>31</sup> | + 2<sup>31</sup> -1 | Integer |
| long | 64 bits | - 2<sup>63</sup> | + 2<sup>63</sup> -1 | Long |
| float | 32 bits | IEEE754 | IEEE754 | Float |
| double | 64 bits |IEEE754 | IEEE754 | Double |
| void | — | — | — | Void |  
数值类型都是有正负之分的，布尔类型的大小没有明确规定，基本类型都有自己的包装类型，但是这样就会存储在堆内存中（其实，java中还有两种数据类型BigInteger 和 BigDecimal，但是他们没有基本数据类型，可以用于高精度的计算）。  
这里就会引入“装箱”和“拆箱”的概念
```
Character ch = 'x';//自动装箱，基本类型自动转换为包装类型
char c = ch;//自动拆箱，包装类型自动转换为基本类型
```  

数组的存储  
Java使用数组前，必须初始化，且无法访问数组长度以外的数据，范围检查代价小，但是换来了安全和效率。  
创建数组其实是创建了一个引用数组，每个引用为null，使用该数组前，要为每一个引用指定一个对象，如果使用的引用为null就会在运行的时候报错。  
如果是基本类型的数组，则会将该数组的内存全部置为0，保证完成初始化。  

2 对象清理
-  
Java的变量需要在其作用域中才可以使用。  
```
{
    String s = new String("a string");
} 
// 作用域终点
```  
 s 在作用域终点就结束了，虽然无法访问这个对象了，但是只要你需要，new 出来的对象就会一直存活下去。（由于Java 的垃圾收集器会检查所有 new 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用，不必担心内存回收的问题）  

 类决定了某一类对象的无关和行为，即确定了对象的类型。

 3 类的创建
 -  

```
//类创建
class ATypeName {
 // 这里是类的内部
}
//对象创建
ATypeName a = new ATypeName();
```  
对于一个类，里面主要有两种元素：  
* 字段  
    可以是基本类型，也可以是引用类型。基本类型在Java初始化类的时候回被赋予一个初始值（不适用于局部变量）。
    | 基本类型 | 初始值 |
    | :-----: |:-----: |
    | boolean | false |
    | char | \u0000 (null) |
    | byte | (byte) 0 |
    | short |(short) 0 |
    | int | 0 |
    | long | 0L |
    | float | 0.0f |
    | double | 0.0d |
* 方法  
    ```
     [返回类型] [方法名](/*参数列表*/){
        // 方法体
    }
    ```  
    返回类型为调用方法时返回的结果类型（void 表明无需返回值，此时， return关键字仅用于退出方法，可被省略），参数列表则表示可被传递到方法内部的参数类型及名称，方法名和参数列表统称为方法签名，签名是方法的唯一标识。  

其中，比较特殊的是，static关键字修饰后，该字段或方法不依赖于任何特定的对象实例，即使从未创建过该类的对象，也可以调用其静态方法或访问其静态字段（静态字段共享存储空间，与对象数量无关，静态方法与此类的任何对象无关，即使没有对象也可以调用该方法，通常直接利用类来调用静态字段或静态方法）。  

小知识：  
1.名称冲突：多个模块中，使用相同的名称可能会发生冲突，java中通过为一个类库生成一个明确的名称来避免这样的冲突（反向使用域名，域名通常是惟一的）。  
2.Java每个源文件中允许有多个类，但是源文件名称必须和其中一个类同名，否则编译报错。要求类名的首字母大写，类名是由多个单词构成的，则每个单词的首字母都应大写（驼峰命名法）。另外，对于几乎所有其他方法，字段和对象引用名都采用驼峰命名的方式，但首字母不需要大写（总而言之，不清楚的时候用驼峰命名法是没错的）。   
3.每个独立程序都要有main()方法作为入口。  
4.`javac 类文件名` 进行编译；`java 类名称` 运行程序。  
