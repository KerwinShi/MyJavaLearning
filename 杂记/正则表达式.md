正则表达式系统学习：

***
基础部分
***

1.元字符 
=  
最基础的构成  
| 元字符 | 含义 |
| :----: | :----: | 
| . | 匹配除换行符以外的任意字符 |
| \w | 匹配字母、数字、下划线或汉字 |
| \s | 匹配任意的空白符 |
| \d | 匹配数字 |
| \b | 匹配单词的开始或结束 |
| ^ | 匹配字符串的开始 |
| $ | 匹配字符串的结束 |

```
匹配有abc开头的字符串
\babc或者^abc

匹配8位数字的QQ号码
^\d\d\d\d\d\d\d\d$

匹配1开头11位数字的手机号码
^1\d\d\d\d\d\d\d\d\d\d$
```

2.重复限定符
=  
有了元字符，就可以写很多的正则表达式了，但是这样写太长了，一堆一堆的重复操作，可以但是没必要  
为了省去这些重复性劳动，就需要重复限定符了  
| 重复限定符 | 含义 |
| :----: | :----: | 
| * | 重复0次或更多次 |
| + | 重复1次或更多次 |
| + | 重复0次或1次 |
| {n} | 重复n次 |
| {n,} | 重复n次或更多次 |
| {n,m} | 重复n次到m次 |

```
匹配8位数字的QQ号码
^\d{8}$

匹配1开头11位数字的手机号码
^1\d{10}$
```  

3.分组  
=  
正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。  
```
匹配字符串中包含0到多个ab开头
^(ab)*
```  

4.转义
=  
由于上述的元字符、重复限定符和（）等具有特殊含义了，如果在正则表示式中需要用到时就需要加以区分，通过转义使其失去特殊含义，作为普通字符被使用。  
```
匹配字符串中包含0到多个(ab)开头
^(\(ab\))*
```

5.条件或(|)
=
利用上面的内容，我们可以实现对满足一种规则的字符进行匹配，但是实际中，我们经常会用到满足多种规则之一就行的情况，如手机号码分段，三大运营商都有几种匹配规则，而不是只有一种。  
```
^(130|131|132|155|156|185|186|145|176)\d{8}$
```

6.区间
=  
条件或中，可能有一部分是可以提取公共部分的，这时候，就可以使用区间  
正则提供一个元字符中括号 [] 来表示区间条件：  
* 限定0到9 可以写成[0-9]
* 限定A-Z 写成[A-Z]
* 限定某些数字 [165]  
```
^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```

***
难度提升
***  

7.零宽断言
=  
断言：在指定的内容前面或者后面会出现满足指定规则的内容（只是匹配位置，不占字符，匹配结果里面不会反悔断言本身）  
零宽：没有宽度  

怎么看都还是觉得太抽象了，果然还是要拿着栗子看比较令人满意  

```
<span class="read-count">阅读数：641</span>
```
我们想要取出上面的数字641

1.正向先行断言  
语法：`(?=pattern)`  
作用：匹配pattern表达式的前面的内容，不包括pattern本身
```java
String reg=".+(?=</span>)";//结果：<span class="read-count">阅读数：641
String reg="\\d+(?=</span>)";//结果：641（这里前面加\\d+,连续的匹配1个或多个数字）
String test = "<span class=\"read-count\">阅读数：641</span>";
Pattern pattern = Pattern.compile(reg);
Matcher mc=    pattern.matcher(test);
while(mc.find()){
    System.out.println("匹配结果：");
    System.out.println(mc.group());
}
```  
2.正向后行断言  
语法：`(?<=pattern)`  
作用：匹配pattern表达式的后面的内容，不包括pattern本身
```java
String reg="(?<=<span class=\"read-count\">阅读数：)\\d+";
```  

有正向也有负向，负向在这里其实就是非的意思。  

3.负向前行断言
语法：`(?!pattern)`  
作用：匹配非pattern表达式的前面内容，不返回本身。
```
 “我爱祖国，我是祖国的花朵”
 正向：要找到'的花朵'前面的 祖国
 负向：要找到不是'的花朵'前面的 祖国 -- -- 祖国(?!的花朵)

```
4.负向后行断言
语法：`(?<!pattern)`  
作用：匹配非pattern表达式的后面内容，不返回本身。  

8.捕获和非捕获  
=  
捕获，其实就是匹配表达式，捕获和分组练习在一起就是捕获组。

匹配子表达式的内容，把匹配结果保存到内存中用数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。

1.数字编号捕获组：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。
语法：`(exp)`  
`(0\d{2})-(\d{8})`有三个分组0,1,2  
2.命名编号捕获组：分组的命名由表达式中的name指定。
语法：`(?<name>exp)`  
`(?<quhao>\0\d{2})-(?<haoma>\d{8})`有三个分组0,quhao,haoma  
3.非捕获组：用来标识那些不需要捕获的分组
语法：`(?:exp)`  
`(?:\0\d{2})-(\d{8})`有两个分组0,1

9.反向引用  
=  
与捕获一起使用，捕获是为了获得匹配表达式的内容，并在内存中保存起来，而反向引用就是去内存中拿来用  
语法：`数字编号组反向引用：\k或\number;命名编号组反向引用：\k或者\'name'`
又捡到一个栗子：  
要查找一串字母"aabbbbgbddesddfiid"里成对的字母
```java
//\w表示匹配一个字母，(\w)做成分组，可以被捕获，\1表示取出第一个分组里面的内容（存的前面一个字母）
 Pattern pattern = Pattern.compile("(\\w)\\1");
```  

10.贪婪与非贪婪
=
贪婪（想多拿多占）  
当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。
`\d{3,6}`实际上匹配三个数字就可以，但是当有更多数字时，会继续匹配，直到达到最大数量。  
多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。
啊哈，又捡到一个栗子：  
```java
String reg="(\\d{1,2})(\\d{3,4})";
String test="61762828 176 2991 87321";
Pattern p1 =Pattern.compile(reg);
Matcher m1 = p1.matcher(test);
while(m1.find()){
    System.out.println(m1.group());
}

//结果
617628//“617628” 是前面的\d{1,2}匹配出了61，后面的匹配出了7628
2991//"2991" 是前面的\d{1,2}匹配出了2 ，后面的匹配出了991(满足匹配优先，再最大程度的贪婪)
87321//"87321"是前面的\d{1,2}匹配出了87，后面的匹配出了321
```

非贪婪（怠惰）  
当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。
`懒惰量词是在贪婪量词后面加个“？”`

11.反义  
=  
| 元字符 | 含义 |
| :----: | :----: | 
| \W | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S | 匹配任意不是空白符的字符 |
| \D | 匹配任意非数字的字符 |
| \B | 匹配不是单词开头或结束的位置 |
| \[^X] | 匹配除了X这个字母以外的任意字符 |